'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var debug = require('debug')('bitcoin-net:peergroup');
var dns = require('dns');
var EventEmitter = require('events');
try {
  var net = require('net');
} catch (err) {}
var ws = require('websocket-stream');
var http = require('http');
var Exchange = require('peer-exchange');
var getBrowserRTC = require('get-browser-rtc');
var once = require('once');
var pumpify = require('pumpify').obj;
var assign = require('object-assign');

var _require = require('blockchain-download');

var BlockStream = _require.BlockStream;
var HeaderStream = _require.HeaderStream;
var TransactionStream = _require.TransactionStream;

var old = require('old');
var Peer = require('./peer.js');
var utils = require('./utils.js');
require('setimmediate');

var DEFAULT_PXP_PORT = 8192; // default port for peer-exchange nodes

var PeerGroup = function (_EventEmitter) {
  _inherits(PeerGroup, _EventEmitter);

  function PeerGroup(params, opts) {
    _classCallCheck(this, PeerGroup);

    utils.assertParams(params);

    var _this = _possibleConstructorReturn(this, (PeerGroup.__proto__ || Object.getPrototypeOf(PeerGroup)).call(this));

    _this._params = params;
    opts = opts || {};
    _this._numPeers = opts.numPeers || 8;
    _this.peers = [];
    _this._hardLimit = opts.hardLimit || false;
    _this.websocketPort = null;
    _this._connectWeb = opts.connectWeb != null ? opts.connectWeb : process.browser;
    _this.connectTimeout = opts.connectTimeout != null ? opts.connectTimeout : 8 * 1000;
    _this.peerOpts = opts.peerOpts != null ? opts.peerOpts : {};
    _this.acceptIncoming = opts.acceptIncoming;
    var acceptIncoming = _this.acceptIncoming;
    _this.connecting = false;
    _this.closed = false;
    _this.accepting = false;

    if (_this._connectWeb) {
      var wrtc = opts.wrtc || getBrowserRTC();
      var envSeeds = process.env.WEB_SEED ? process.env.WEB_SEED.split(',').map(function (s) {
        return s.trim();
      }) : [];
      _this._webSeeds = _this._params.webSeeds.concat(envSeeds);
      try {
        _this._exchange = Exchange(params.magic.toString(16), assign({ wrtc: wrtc, acceptIncoming: acceptIncoming }, opts.exchangeOpts));
      } catch (err) {
        var _ret;

        return _ret = _this._error(err), _possibleConstructorReturn(_this, _ret);
      }
      _this._exchange.on('error', _this._error.bind(_this));
      _this._exchange.on('connect', function (stream) {
        _this._onConnection(null, stream);
      });
      if (!process.browser && acceptIncoming) {
        _this._acceptWebsocket();
      }
    }

    _this.on('block', function (block) {
      _this.emit('block:' + block.header.getHash().toString('base64'), block);
    });
    _this.on('merkleblock', function (block) {
      _this.emit('merkleblock:' + block.header.getHash().toString('base64'), block);
    });
    _this.on('tx', function (tx) {
      _this.emit('tx:' + tx.getHash().toString('base64'), tx);
    });
    _this.once('peer', function () {
      return _this.emit('connect');
    });
    return _this;
  }

  _createClass(PeerGroup, [{
    key: '_error',
    value: function _error(err) {
      this.emit('error', err);
    }

    // callback for peer discovery methods

  }, {
    key: '_onConnection',
    value: function _onConnection(err, socket) {
      var _this2 = this;

      if (err) {
        if (socket) socket.destroy();
        debug('discovery connection error: ' + err.message);
        this.emit('connectError', err, null);
        if (this.connecting) {
          setImmediate(this._connectPeer.bind(this));
        }
        return;
      }
      if (this.closed) return socket.destroy();
      var opts = assign({ socket: socket }, this.peerOpts);
      var peer = new Peer(this._params, opts);
      var onError = function onError(err) {
        err = err || new Error('Connection error');
        debug('peer connection error: ' + err.message);
        peer.removeListener('disconnect', onError);
        _this2.emit('connectError', err, peer);
        if (_this2.connecting) _this2._connectPeer();
      };
      peer.once('error', onError);
      peer.once('disconnect', onError);
      peer.once('ready', function () {
        if (_this2.closed) return peer.disconnect();
        peer.removeListener('error', onError);
        peer.removeListener('disconnect', onError);
        _this2.addPeer(peer);
      });
    }

    // connects to a new peer, via a randomly selected peer discovery method

  }, {
    key: '_connectPeer',
    value: function _connectPeer(cb) {
      var _this3 = this;

      cb = cb || this._onConnection.bind(this);
      if (this.closed) return;
      var getPeerArray = [];
      if (!process.browser) {
        if (this._params.dnsSeeds && this._params.dnsSeeds.length > 0) {
          getPeerArray.push(this._connectDNSPeer.bind(this));
        }
        if (this._params.staticPeers && this._params.staticPeers.length > 0) {
          getPeerArray.push(this._connectStaticPeer.bind(this));
        }
      }
      if (this._connectWeb && this._exchange.peers.length > 0) {
        getPeerArray.push(this._exchange.getNewPeer.bind(this._exchange));
      }
      if (this._params.getNewPeer) {
        getPeerArray.push(this._params.getNewPeer.bind(this._params));
      }
      if (getPeerArray.length === 0) {
        this.connecting = false;
        if (this.connectTimeout) {
          setTimeout(function () {
            _this3.connecting = true;
            setImmediate(_this3.connect.bind(_this3));
          }, this.connectTimeout);
        }
        return this._onConnection(new Error('No methods available to get new peers'));
      }
      var getPeer = utils.getRandom(getPeerArray);
      debug('_connectPeer: getPeer = ' + getPeer.name);
      getPeer(cb);
    }

    // connects to a random TCP peer via a random DNS seed
    // (selected from `dnsSeeds` in the params)

  }, {
    key: '_connectDNSPeer',
    value: function _connectDNSPeer(cb) {
      var _this4 = this;

      var seeds = this._params.dnsSeeds;
      var seed = utils.getRandom(seeds);
      dns.resolve(seed, function (err, addresses) {
        if (err) return cb(err);
        var address = utils.getRandom(addresses);
        _this4._connectTCP(address, _this4._params.defaultPort, cb);
      });
    }

    // connects to a random TCP peer from `staticPeers` in the params

  }, {
    key: '_connectStaticPeer',
    value: function _connectStaticPeer(cb) {
      var peers = this._params.staticPeers;
      var address = utils.getRandom(peers);
      var peer = utils.parseAddress(address);
      this._connectTCP(peer.hostname, peer.port || this._params.defaultPort, cb);
    }

    // connects to a standard protocol TCP peer

  }, {
    key: '_connectTCP',
    value: function _connectTCP(host, port, cb) {
      debug('_connectTCP: tcp://' + host + ':' + port);
      var socket = net.connect(port, host);
      if (this.connectTimeout) {
        var timeout = setTimeout(function () {
          socket.destroy();
          cb(new Error('Connection timed out'));
        }, this.connectTimeout);
      }
      socket.once('error', cb);
      socket.once('connect', function () {
        socket.ref();
        socket.removeListener('error', cb);
        clearTimeout(timeout);
        cb(null, socket);
      });
      socket.unref();
    }

    // connects to the peer-exchange peers provided by the params

  }, {
    key: '_connectWebSeeds',
    value: function _connectWebSeeds() {
      var _this5 = this;

      this._webSeeds.forEach(function (seed) {
        debug('connecting to web seed: ' + JSON.stringify(seed, null, '  '));
        var socket = ws(seed);
        socket.on('error', function (err) {
          return _this5._error(err);
        });
        _this5._exchange.connect(socket, function (err, peer) {
          if (err) {
            debug('error connecting to web seed (pxp): ' + JSON.stringify(seed, null, '  ') + ' ' + err.stack);
            return;
          }
          debug('connected to web seed: ' + JSON.stringify(seed, null, '  '));
          _this5.emit('webSeed', peer);
        });
      });
    }
  }, {
    key: '_assertPeers',
    value: function _assertPeers() {
      if (this.peers.length === 0) {
        throw new Error('Not connected to any peers');
      }
    }
  }, {
    key: '_fillPeers',
    value: function _fillPeers() {
      if (this.closed) return;

      // TODO: smarter peer logic (ensure we don't have too many peers from the
      // same seed, or the same IP block)
      var n = this._numPeers - this.peers.length;
      debug('_fillPeers: n = ' + n + ', numPeers = ' + this._numPeers + ', peers.length = ' + this.peers.length);
      for (var i = 0; i < n; i++) {
        this._connectPeer();
      }
    }

    // sends a message to all peers

  }, {
    key: 'send',
    value: function send(command, payload, assert) {
      assert = assert != null ? assert : true;
      if (assert) this._assertPeers();
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.peers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var peer = _step.value;

          peer.send(command, payload);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }

    // initializes the PeerGroup by creating peer connections

  }, {
    key: 'connect',
    value: function connect(onConnect) {
      var _this6 = this;

      debug('connect called');
      this.connecting = true;
      if (onConnect) this.once('connect', onConnect);

      // first, try to connect to web seeds so we can get web peers
      // once we have a few, start filling peers via any random
      // peer discovery method
      if (this._connectWeb && this._params.webSeeds && this._webSeeds.length) {
        this.once('webSeed', function () {
          return _this6._fillPeers();
        });
        return this._connectWebSeeds();
      }

      // if we aren't using web seeds, start filling with other methods
      this._fillPeers();
    }

    // disconnect from all peers and stop accepting connections

  }, {
    key: 'close',
    value: function close(cb) {
      var _this7 = this;

      if (cb) cb = once(cb);else cb = function cb(err) {
        if (err) _this7._error(err);
      };

      debug('close called: peers.length = ' + this.peers.length);
      this.closed = true;
      if (this.peers.length === 0) return cb(null);
      var peers = this.peers.slice(0);
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = peers[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var peer = _step2.value;

          peer.once('disconnect', function () {
            if (_this7.peers.length === 0) cb(null);
          });
          peer.disconnect(new Error('PeerGroup closing'));
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
  }, {
    key: '_acceptWebsocket',
    value: function _acceptWebsocket(port, cb) {
      var _this8 = this;

      if (process.browser) return cb(null);
      if (!port) port = DEFAULT_PXP_PORT;
      this.websocketPort = port;
      var server = http.createServer();
      ws.createServer({ server: server }, function (stream) {
        _this8._exchange.accept(stream);
      });
      http.listen(port);
      cb(null);
    }

    // manually adds a Peer

  }, {
    key: 'addPeer',
    value: function addPeer(peer) {
      var _this9 = this;

      if (this.closed) throw new Error('Cannot add peers, PeerGroup is closed');

      this.peers.push(peer);
      debug('add peer: peers.length = ' + this.peers.length);

      if (this._hardLimit && this.peers.length > this._numPeers) {
        var disconnectPeer = this.peers.shift();
        disconnectPeer.disconnect(new Error('PeerGroup over limit'));
      }

      var onMessage = function onMessage(message) {
        _this9.emit('message', message, peer);
        _this9.emit(message.command, message.payload, peer);
      };
      peer.on('message', onMessage);

      peer.once('disconnect', function (err) {
        var index = _this9.peers.indexOf(peer);
        _this9.peers.splice(index, 1);
        peer.removeListener('message', onMessage);
        debug('peer disconnect, peer.length = ' + _this9.peers.length + ', reason=' + err + '\n' + err.stack);
        if (_this9.connecting) _this9._fillPeers();
        _this9.emit('disconnect', peer, err);
      });
      peer.on('error', function (err) {
        _this9.emit('peerError', err);
        peer.disconnect(err);
      });

      this.emit('peer', peer);
    }
  }, {
    key: 'randomPeer',
    value: function randomPeer() {
      this._assertPeers();
      return utils.getRandom(this.peers);
    }
  }, {
    key: 'createHeaderStream',
    value: function createHeaderStream(opts) {
      return new HeaderStream(this, opts);
    }
  }, {
    key: 'createBlockStream',
    value: function createBlockStream(opts) {
      return new BlockStream(this, opts);
    }
  }, {
    key: 'createTransactionStream',
    value: function createTransactionStream(opts) {
      var blocks = new BlockStream(this, opts);
      var txs = pumpify(blocks, TransactionStream());
      txs.blocks = blocks;
      return txs;
    }
  }, {
    key: 'getBlocks',
    value: function getBlocks(hashes, opts, cb) {
      this._request('getBlocks', hashes, opts, cb);
    }
  }, {
    key: 'getTransactions',
    value: function getTransactions(blockHash, txids, opts, cb) {
      this._request('getTransactions', blockHash, txids, opts, cb);
    }
  }, {
    key: 'getHeaders',
    value: function getHeaders(locator, opts, cb) {
      this._request('getHeaders', locator, opts, cb);
    }

    // calls a method on a random peer,
    // and retries on another peer if it times out

  }, {
    key: '_request',
    value: function _request(method) {
      var _this10 = this,
          _arguments = arguments;

      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      var cb = args.pop();
      var peer = this.randomPeer();
      args.push(function (err, res) {
        if (_this10.closed) return;
        if (err && err.timeout) {
          // if request times out, disconnect peer and retry with another random peer
          debug('peer request "' + method + '" timed out, disconnecting');
          peer.disconnect(err);
          _this10.emit('requestError', err);
          return _this10._request.apply(_this10, _arguments);
        }
        cb(err, res, peer);
      });
      peer[method].apply(peer, args);
    }
  }]);

  return PeerGroup;
}(EventEmitter);

module.exports = old(PeerGroup);