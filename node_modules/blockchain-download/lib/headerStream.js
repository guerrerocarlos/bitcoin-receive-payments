'use strict';

var Transform = require('stream').Transform;
var util = require('util');
var debug = require('debug')('blockchain-download:headerstream');
var INV = require('bitcoin-protocol').constants.inventory;

var HeaderStream = module.exports = function (peers, opts) {
  var _this = this;

  if (!peers) {
    throw new Error('"peers" argument is required for HeaderStream');
  }
  if (!(this instanceof HeaderStream)) {
    return new HeaderStream(peers, opts);
  }
  Transform.call(this, { objectMode: true });
  opts = opts || {};
  this.peers = peers;
  this.timeout = opts.timeout;
  this.stop = opts.stop;
  this.lookAhead = opts.lookAhead != null ? opts.lookAhead : true;
  this.done = false;
  this.reachedTip = false;
  this.lastLocator = null;
  this.lookAheadHash = null;
  this.lookAheadHeaders = null;
  this.lookAheadPeer = null;
  if (opts.endOnTip) {
    this.once('tip', function () {
      return _this.end();
    });
  }
};
util.inherits(HeaderStream, Transform);

HeaderStream.prototype._error = function (err) {
  this.emit('error', err);
};

HeaderStream.prototype._transform = function (locator, enc, cb) {
  var _this2 = this;

  this.lastLocator = locator;
  if (this.reachedTip) return cb(null);
  if (this.lookAheadHeaders && this.lookAheadHeaders[0].prevHash.equals(locator[0])) {
    // we already looked up next blocks, return them to handler
    var headers = this.lookAheadHeaders;
    this.lookAheadHeaders = null;
    this._onHeaders(headers, this.lookAheadPeer, cb);
    return;
  }
  if (this.lookAheadHash) {
    // inflight lookahead request
    if (this.lookAheadHash.equals(locator[0])) {
      // previous request was validated, inflight request is correct
      this.once('lookahead:' + this.lookAheadHash.toString('base64'), function (headers, peer) {
        _this2._onHeaders(headers, peer, cb);
      });
      return;
    } else {
      // previous blocks were invalid, lookahead should be ignored
      this.lookAheadHash = null;
    }
  }
  this._getHeaders(locator, function (err, headers, peer) {
    if (err) return _this2._error(err);
    _this2._onHeaders(headers, peer, cb);
  });
};

HeaderStream.prototype._getHeaders = function (locator, peer, cb) {
  if (this.done) return;
  if (typeof peer === 'function') {
    cb = peer;
    peer = null;
  }
  peer = peer || this.peers;
  peer.getHeaders(locator, {
    stop: this.stop,
    timeout: this.timeout
  }, cb);
};

HeaderStream.prototype._onHeaders = function (headers, peer, cb) {
  var _this3 = this;

  if (this.done) return cb(null);
  if (headers.length === 0) {
    this._onTip(peer);
    if (cb) cb(null);
    return;
  }
  headers.peer = peer;
  this.push(headers);
  if (headers.length < 2000) {
    this._onTip(peer);
    if (cb) cb(null);
    return;
  }
  var lastHash = headers[headers.length - 1].getHash();
  if (this.stop && lastHash.compare(this.stop) === 0) {
    this.end();
  }
  if (this.lookAhead) {
    this.lookAheadHash = lastHash;
    this._getHeaders([lastHash], function (err, headers, peer) {
      _this3.lookAheadHash = null;
      if (err) return _this3._error(err);
      _this3.lookAheadHeaders = headers;
      _this3.lookAheadPeer = peer;
      _this3.emit('lookahead:' + lastHash.toString('base64'), headers, peer);
    });
  }
  if (cb) cb(null);
};

HeaderStream.prototype.end = function () {
  if (this.done) return;
  this.done = true;
  Transform.prototype.end.call(this);
};

HeaderStream.prototype._onTip = function (peer) {
  if (this.reachedTip) return;
  debug('Reached chain tip, now listening for relayed blocks');
  this.reachedTip = true;
  this.emit('tip');
  if (!this.done) this._subscribeToInvs();
};

HeaderStream.prototype._subscribeToInvs = function () {
  var _this4 = this;

  var lastSeen = [];
  this.peers.on('inv', function (inv, peer) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = inv[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var item = _step.value;

        if (item.type !== INV.MSG_BLOCK) continue;
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = lastSeen[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var hash = _step2.value;

            if (hash.equals(item.hash)) return;
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }

        lastSeen.push(item.hash);
        if (lastSeen.length > 8) lastSeen.shift();
        _this4._getHeaders(_this4.lastLocator, peer, function (err, headers, peer) {
          if (err) return _this4._error(err);
          _this4._onHeaders(headers, peer, function () {});
        });
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  });
};